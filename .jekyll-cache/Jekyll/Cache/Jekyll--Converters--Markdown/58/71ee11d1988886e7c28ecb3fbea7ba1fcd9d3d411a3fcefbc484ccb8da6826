I"c<ul id="markdown-toc">
  <li><a href="#获取目录列表" id="markdown-toc-获取目录列表">获取目录列表</a>    <ul>
      <li><a href="#使用现代python版本获取目录列表" id="markdown-toc-使用现代python版本获取目录列表">使用现代Python版本获取目录列表</a></li>
      <li><a href="#列出目录中所有文件" id="markdown-toc-列出目录中所有文件">列出目录中所有文件</a></li>
      <li><a href="#列出所有子目录" id="markdown-toc-列出所有子目录">列出所有子目录</a></li>
    </ul>
  </li>
  <li><a href="#获取文件属性" id="markdown-toc-获取文件属性">获取文件属性</a></li>
  <li><a href="#创建目录" id="markdown-toc-创建目录">创建目录</a>    <ul>
      <li><a href="#创建单个目录" id="markdown-toc-创建单个目录">创建单个目录</a></li>
      <li><a href="#创建多个目录" id="markdown-toc-创建多个目录">创建多个目录</a></li>
    </ul>
  </li>
  <li><a href="#文件名模式匹配" id="markdown-toc-文件名模式匹配">文件名模式匹配</a>    <ul>
      <li><a href="#字符串方法匹配" id="markdown-toc-字符串方法匹配">字符串方法匹配</a></li>
      <li><a href="#使用-fnmatch-进行简单文件名模式匹配" id="markdown-toc-使用-fnmatch-进行简单文件名模式匹配">使用 <code class="highlighter-rouge">fnmatch</code> 进行简单文件名模式匹配</a></li>
      <li><a href="#使用-glob-进行文件名模式匹配" id="markdown-toc-使用-glob-进行文件名模式匹配">使用 <code class="highlighter-rouge">glob</code> 进行文件名模式匹配</a></li>
    </ul>
  </li>
</ul>

<p>此文与《文件操作》配合食用味道更佳。</p>

<p>Ref:</p>
<ul>
  <li><a href="https://juejin.im/post/5c57afb1f265da2dda6924a1#heading-38">掘金：文件与文件夹操作</a></li>
</ul>

<p>假设你当前的工作目录有一个叫 <code class="highlighter-rouge">my_directory</code> 的子目录，该目录包含如下内容：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>.
├── file1.py
├── file2.csv
├── file3.txt
├── sub_dir
│   ├── bar.py
│   └── foo.py
├── sub_dir_b
│   └── file4.txt
└── sub_dir_c
    ├── config.py
    └── file5.txt
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="获取目录列表">获取目录列表</h2>

<h4 id="使用现代python版本获取目录列表">使用现代Python版本获取目录列表</h4>
<p>在现代Python版本中，可以使用 <code class="highlighter-rouge">os.scandir()</code> 和 <code class="highlighter-rouge">pathlib.Path</code> 来替代旧版本中的 <del><code class="highlighter-rouge">os.listdir()</code></del></p>

<p><code class="highlighter-rouge">os.scandir()</code> 调用时返回一个迭代器而不是一个列表。<em>其(小火的理解)</em> （<code class="highlighter-rouge">ScandirIterator</code>）指向了当前目录中的所有条目。你可以遍历迭代器的内容，并打印文件名。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="k">with</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="s">'my_directory'</span><span class="p">)</span> <span class="k">as</span> <span class="n">entries</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p>运行结果为</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>file1.py
file2.csv
file3.txt
sub_dir
sub_dir_b
sub_dir_c
</pre></td></tr></tbody></table></code></pre></div></div>

<p>另一个获取目录列表的方法是使用 <code class="highlighter-rouge">pathlib</code> 模块：<a href="https://juejin.im/post/5c57afb1f265da2dda6924a1#heading-3">前往原文 →</a></p>

<h4 id="列出目录中所有文件">列出目录中所有文件</h4>

<p>如果不希望列出目录，而仅列出文件，要使用 <code class="highlighter-rouge">os.path</code> ：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">os</span>

<span class="n">basepath</span> <span class="o">=</span> <span class="s">'my_directory'</span>
<span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">basepath</span><span class="p">):</span>
    <span class="c1"># 使用os.path.isfile判断该路径是否是文件类型
</span>    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base_path</span><span class="p">,</span> <span class="n">entry</span><span class="p">)):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>在这里调用 <code class="highlighter-rouge">os.listdir()</code> 返回指定路径中所有内容的列表，接着使用 <code class="highlighter-rouge">os.path.isfile()</code> 过滤列表让其只显示文件类型而非目录类型。代码执行结果如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>file1.py
file2.csv
file3.txt
</pre></td></tr></tbody></table></code></pre></div></div>

<p>一个更简单的方式来列出一个目录中所有的文件是使用 <code class="highlighter-rouge">os.scandir()</code> 或 <code class="highlighter-rouge">pathlib.Path()</code> :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">os</span>

<span class="n">basepath</span> <span class="o">=</span> <span class="s">'my_directory'</span>
<span class="k">with</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="n">basepath</span><span class="p">)</span> <span class="k">as</span> <span class="n">entries</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">entry</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="k">print</span><span class="p">(</span><span class="n">entry</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>使用 <code class="highlighter-rouge">os.scandir()</code> 比起 <code class="highlighter-rouge">os.listdir()</code> 看上去更清楚和更容易理解。对 <code class="highlighter-rouge">ScandirIterator</code> 的每一项调用 <code class="highlighter-rouge">entry.isfile()</code> ，如果返回 <code class="highlighter-rouge">True</code> 则表示这一项是一个文件。上述代码的输出如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>file1.py
file2.csv
file3.txt
</pre></td></tr></tbody></table></code></pre></div></div>
<p>如何使用 <code class="highlighter-rouge">pathlib.Path()</code> 列出一个目录中的文件：<a href="https://juejin.im/post/5c57afb1f265da2dda6924a1#heading-3">前往原文 →</a></p>

<h4 id="列出所有子目录">列出所有子目录</h4>

<p>与上面讨论的相反，如果希望列出子目录，而不列出文件：<a href="https://juejin.im/post/5c57afb1f265da2dda6924a1#heading-5">前往原文 →</a></p>

<h2 id="获取文件属性">获取文件属性</h2>

<p>Python可以很轻松的获取文件大小和修改时间等文件属性。</p>

<p><code class="highlighter-rouge">os.scandir()</code> 和 <code class="highlighter-rouge">pathlib.Path()</code> 能直接获取到包含文件属性的目录列表。这可能比使用 <code class="highlighter-rouge">os.listdir()</code> 列出文件然后获取每个文件的文件属性信息更加有效。</p>

<p>下面的例子显示了如何获取 <code class="highlighter-rouge">my_directory</code> 中文件的最后修改时间。以时间戳的方式输出：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">os</span>

<span class="k">with</span> <span class="n">os</span><span class="o">.</span><span class="n">scandir</span><span class="p">(</span><span class="s">'my_directory'</span><span class="p">)</span> <span class="k">as</span> <span class="n">entries</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">entries</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">entry</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">st_mtime</span><span class="p">)</span>

<span class="s">"""
1548163662.3952665
1548163689.1982062
1548163697.9175904
1548163721.1841028
1548163740.765162
1548163769.4702623
"""</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">os.scandir()</code> 返回一个 <code class="highlighter-rouge">ScandirIterator</code> 对象。<code class="highlighter-rouge">ScandirIterator</code> 对象中的每一项有 <code class="highlighter-rouge">.stat()</code> 方法能获取关于它指向文件或目录的信息。<code class="highlighter-rouge">.stat()</code> 提供了例如文件大小和最后修改时间的信息。在上面的示例中，代码打印了 <code class="highlighter-rouge">st_time</code> 属性，该属性是上次修改文件内容的时间。</p>

<p><code class="highlighter-rouge">pathlib </code>模块具有相应的方法。略。</p>

<h2 id="创建目录">创建目录</h2>
<p>暂时跳过：<a href="https://juejin.im/post/5c57afb1f265da2dda6924a1#heading-7">原文 →</a></p>

<h4 id="创建单个目录">创建单个目录</h4>

<h4 id="创建多个目录">创建多个目录</h4>

<h2 id="文件名模式匹配">文件名模式匹配</h2>

<p>使用上述方法之一获取目录中的文件列表后，你可能希望搜索和特定的模式匹配的文件。</p>

<p>本小节的示例将在名为 <code class="highlighter-rouge">some_directory</code> 的目录下执行，该目录具有以下的结构：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>.
├── admin.py
├── data_01_backup.txt
├── data_01.txt
├── data_02_backup.txt
├── data_02.txt
├── data_03_backup.txt
├── data_03.txt
├── sub_dir
│   ├── file1.py
│   └── file2.py
└── tests.py
</pre></td></tr></tbody></table></code></pre></div></div>

<p>可以使用 Bash shell，你可以使用以下的命令创建上述目录结构。（跳过）</p>

<h4 id="字符串方法匹配">字符串方法匹配</h4>

<p>Python有几个内置 修改和操作字符串 的方法。当在匹配文件名时，其中的两个方法 <code class="highlighter-rouge">.startswith()</code> 和 <code class="highlighter-rouge">.endswith()</code> 非常有用。要做到这点，首先要获取一个目录列表，然后遍历。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">os</span>

<span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s">'some_directory'</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">f_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">'.txt'</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>复制代码上述代码找到 <code class="highlighter-rouge">some_directory</code> 中的所有文件，遍历并使用 <code class="highlighter-rouge">.endswith()</code> 来打印所有扩展名为 <code class="highlighter-rouge">.txt</code> 的文件名。运行代码在我的电脑上输出如下:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>data_01.txt
data_01_backup.txt
data_02.txt
data_02_backup.txt
data_03.txt
data_03_backup.txt
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="使用-fnmatch-进行简单文件名模式匹配">使用 <code class="highlighter-rouge">fnmatch</code> 进行简单文件名模式匹配</h4>

<p>字符串方法匹配的能力是有限的。<code class="highlighter-rouge">fnmatch</code> 有对于模式匹配有更先进的函数和方法。我们将考虑使用 <code class="highlighter-rouge">fnmatch.fnmatch()</code> ，这是一个支持使用 <code class="highlighter-rouge">*</code> 和 <code class="highlighter-rouge">?</code> 等通配符的函数。例如，使用 <code class="highlighter-rouge">fnmatch</code> 查找目录中所有 <code class="highlighter-rouge">.txt</code> 文件，你可以这样做:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>

<span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s">'some_directory'</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="s">'*.txt'</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>
    <p>迭代 <code class="highlighter-rouge">some_directory</code> 中的文件列表，并使用 <code class="highlighter-rouge">.fnmatch()</code> 对扩展名为 <code class="highlighter-rouge">.txt</code> 的文件执行通配符搜索。</p>
  </li>
  <li>
    <p>据我查阅的资料，<code class="highlighter-rouge">*</code>匹配任意多个字符，而<code class="highlighter-rouge">?</code>匹配任意单个字符。此处字符为 <code class="highlighter-rouge">a~z</code>，<code class="highlighter-rouge">A~Z</code>和<code class="highlighter-rouge">0~9</code>共 36 个字符。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">fnmatch()</code> 函数匹配能力介于简单的字符串方法和强大的正则表达式之间。 如果在数据处理操作中只需要简单的通配符就能完成的时候，这通常是一个比较合理的方案。</p>
  </li>
</ul>

<p>更复杂地，如果想要搜索类似于 <code class="highlighter-rouge">data_01_backup</code>这类文件，你可以这样使用 <code class="highlighter-rouge">fnmatch.fnmatch()</code></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">fnmatch</span>

<span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="s">'some_directory'</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">fnmatch</span><span class="o">.</span><span class="n">fnmatch</span><span class="p">(</span><span class="n">f_name</span><span class="p">,</span> <span class="s">'data_*_backup.txt'</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>输出如下 :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>data_01_backup.txt
data_02_backup.txt
data_03_backup.txt
</pre></td></tr></tbody></table></code></pre></div></div>

<h4 id="使用-glob-进行文件名模式匹配">使用 <code class="highlighter-rouge">glob</code> 进行文件名模式匹配</h4>

<p>另一个有用的模式匹配模块是 <code class="highlighter-rouge">glob</code> 。</p>

<p><code class="highlighter-rouge">.glob()</code> 在 <code class="highlighter-rouge">glob</code> 模块中的左右就像 <code class="highlighter-rouge">fnmatch.fnmatch()</code>，但是与 <code class="highlighter-rouge">fnmach.fnmatch()</code> 不同的是，它将以 <code class="highlighter-rouge">.</code> 开头的文件视为特殊文件。</p>

<p>UNIX和相关系统在文件列表中使用通配符像 <code class="highlighter-rouge">?</code> 和 <code class="highlighter-rouge">*</code> 表示全匹配。</p>

<p>例如，在UNIX shell中使用 <code class="highlighter-rouge">mv *.py python_files</code> 移动所有 <code class="highlighter-rouge">.py</code> 扩展名 的文件从当前目录到 <code class="highlighter-rouge">python_files</code> 。这 <code class="highlighter-rouge">*</code> 是一个通配符表示任意数量的字符，<code class="highlighter-rouge">*.py</code> 是一个全模式。Windows 操作系统中不提供此 shell 功能。但 <code class="highlighter-rouge">glob</code> 模块在 Python 中添加了此功能，使得 Windows 程序可以使用这个特性。</p>

<p>这里有一个使用 <code class="highlighter-rouge">glob</code> 模块在当前目录下查询所有 Python 代码文件:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">glob</span>

<span class="k">print</span><span class="p">(</span><span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'*.py'</span><span class="p">))</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">glob.glob('*.py')</code> 搜索当前目录中具有 <code class="highlighter-rouge">.py</code> 扩展名的文件，并且将它们以列表的形式返回。 <code class="highlighter-rouge">glo</code>b 还支持 shell 样式的通配符来进行匹配 :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">glob</span>

<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s">'*[0-9]*.txt'</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这将找到所有文件名中包含数字的文本文件(.txt) :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>data_01.txt
data_01_backup.txt
data_02.txt
data_02_backup.txt
data_03.txt
data_03_backup.txt
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">glob</code> 也很容易在子目录中递归的搜索文件:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">glob</span>

<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">glob</span><span class="o">.</span><span class="n">iglob</span><span class="p">(</span><span class="s">'**/*.py'</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>这里例子使用了 <code class="highlighter-rouge">glob.iglob()</code> 在当前目录和子目录中搜索所有的 <code class="highlighter-rouge">.py</code> 文件。传递 <code class="highlighter-rouge">recursive=True</code> 作为 <code class="highlighter-rouge">.iglob()</code> 的参数使其搜索当前目录和子目录中的 <code class="highlighter-rouge">.py</code> 文件。<code class="highlighter-rouge">glob.glob()</code> 和 <code class="highlighter-rouge">glob.iglob()</code> 不同之处在于，<code class="highlighter-rouge">iglob()</code> 返回一个迭代器而不是一个列表。</p>

<p>运行上述代码会得到以下结果:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>admin.py
tests.py
sub_dir/file1.py
sub_dir/file2.py
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="highlighter-rouge">pathlib</code> 也包含类似的方法来灵活的获取文件列表。（略）</p>

<hr />
<p><strong>Friendly reminder:</strong> This series are my own study notes of <strong><a href="https://github.com/jackfrued/Python-100-Days">Python-100-Days</a></strong>. I do not own copyright of some of the content. Nor is this a good tutorial of Python. I really appreciate it if you notice any mistakes or errors and tell me. Sorry that things copied from <a href="https://github.com/jackfrued/Python-100-Days">Python-100-Days</a> will not be noted due to huge workload. <strong>The whole series are not allowed to be reproduced</strong>. View <strong><a href="https://mikelyou.com/2020/01/02/python-learning-00-readme/">python-learning-readme</a></strong>.</p>
:ET